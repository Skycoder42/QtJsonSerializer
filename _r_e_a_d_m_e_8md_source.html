<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>QtJsonSerializer: README.md Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" style="display: inline;">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">QtJsonSerializer
   &#160;<span id="projectnumber">3.2.0</span>
   </div>
   <div id="projectbrief">A library to perform generic seralization and deserialization of QObjects</div>
  </td>
 </tr>
 </tbody>
</table>
<a style="float: right;" target="_blank"  href="https://github.com/Skycoder42/QJsonSerializer">
<img style="padding: 10px;" src="GitHub_Logo.png"/>
</a>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">README.md</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;[TOC]</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;A library to perform generic seralization and deserialization of QObjects.</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;With this small library, you are able to serialize any QObject or Q_GADGET class to JSON and back. This is done with help of Qt&#39;s meta system.</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;[![Travis Build Status](https://travis-ci.org/Skycoder42/QtJsonSerializer.svg?branch=master)](https://travis-ci.org/Skycoder42/QtJsonSerializer)</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;[![Appveyor Build status](https://ci.appveyor.com/api/projects/status/rbue7wwxk04eoka0/branch/master?svg=true)](https://ci.appveyor.com/project/Skycoder42/qtjsonserializer/branch/master)</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;[![Codacy Badge](https://api.codacy.com/project/badge/Grade/3f69dd82640e4e3b8526f1a54bec2264)](https://www.codacy.com/app/Skycoder42/QtJsonSerializer)</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;[![AUR](https://img.shields.io/aur/version/qt5-jsonserializer.svg)](https://aur.archlinux.org/packages/qt5-jsonserializer/)</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;# Features {#qtjsonserializer_readme_label_0}</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;- Serialize QObjects, Q_GADGETS, lists, maps, etc. to JSON, in a generic matter</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;- ... and of course deserialize JSON back as well</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;- De/serialize any QVariant - as long as it contains only basic types or one of the above</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;   - Works even with QJsonValue/Array/Object as properties</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;- Serializes Q_PROPERTY elements</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;- Enum de/serialization as integer or as string</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;- Deserialization: Additional JSON-values will be stored as dynamic properties for QObjects</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;- Supports polymorphism</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;- Fully Unit-Tested</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;- Thread-Safe</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;- Easily extensible</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;# Download/Installation {#qtjsonserializer_readme_label_1}</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;There are multiple ways to install the Qt module, sorted by preference:</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;1. Package Managers: The library is available via:</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;   - **Arch-Linux:** AUR-Repository: [`qt5-jsonserializer`](https://aur.archlinux.org/packages/qt5-jsonserializer/)</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;   - **Ubuntu Bionic:** Launchpad-PPA: [ppa:skycoder42/qt-modules](https://launchpad.net/~skycoder42/+archive/ubuntu/qt-modules), package `libqt5jsonserializer[3/-dev]`</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;   - **Flatpak Module template:** [Skycoder42/deployment qtjsonserializer.json](https://github.com/Skycoder42/deployment/blob/master/flatpak/modules/qtjsonserializer/qtjsonserializer.json)</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;   - **MacOs:**</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;       - Tap: [`brew tap Skycoder42/qt-modules`](https://github.com/Skycoder42/homebrew-qt-modules)</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;       - Package: `qtjsonserializer`</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;       - **IMPORTANT:** Due to limitations of homebrew, you must run `source /usr/local/opt/qtjsonserializer/bashrc.sh` before you can use the module.</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;2. Simply add my repository to your Qt MaintenanceTool (Image-based How-To here: [Add custom repository](https://github.com/Skycoder42/QtModules/blob/master/README.md#add-my-repositories-to-qt-maintenancetool)):</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;   1. Start the MaintenanceTool from the commandline using `/path/to/MaintenanceTool --addTempRepository &lt;url&gt;` with one of the following urls (GUI-Method is currently broken, see [QTIFW-1156](https://bugreports.qt.io/browse/QTIFW-1156)) - This must be done *every time* you start the tool:</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;       - On Linux: https://install.skycoder42.de/qtmodules/linux_x64</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;       - On Windows: https://install.skycoder42.de/qtmodules/windows_x86</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;       - On Mac: https://install.skycoder42.de/qtmodules/mac_x64</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;   2. A new entry appears under all supported Qt Versions (e.g. `Qt &gt; Qt 5.11 &gt; Skycoder42 Qt modules`)</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;   3. You can install either all of my modules, or select the one you need: `Qt Json Serializer`</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;   4. Continue the setup and thats it! you can now use the module for all of your installed Kits for that Qt</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;3. Download the compiled modules from the release page. **Note:** You will have to add the correct ones yourself and may need to adjust some paths to fit your installation!</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;4. Build it yourself! **Note:** This requires perl to be installed. If you don&#39;t have/need cmake, you can ignore the related warnings. To automatically build and install to your Qt installation, run:</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;   - `qmake`</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;   - `make qmake_all`</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;   - `make`</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;   - Optional steps:</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;       - `make doxygen` to generate the documentation</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;       - `make -j1 run-tests` to build and run all tests</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;   - `make install`</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;# Usage {#qtjsonserializer_readme_label_2}</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;The serializer is provided as a Qt module. Thus, all you have to do is install the module, and then, in your project, add `QT += jsonserializer` to your `.pro` file! The following chapters show an example and explain a few important details regarding the functionality and limits of the implementation.</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;## Example {#qtjsonserializer_readme_label_3}</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;Both serialization and desertialization are rather simple. Create an object, and then use the serializer as follows:</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;The following is an example for a serializable object. *Note:* The usage of `MEMBER` Properties is not required, and simply done to make this example more readable.</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;```cpp</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;class TestObject : public QObject</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;{</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;   Q_OBJECT</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;   Q_PROPERTY(QString stringProperty MEMBER stringProperty)</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;   Q_PROPERTY(QList&lt;int&gt; simpleList MEMBER simpleList)</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;   Q_PROPERTY(QMap&lt;QString, double&gt; simpleMap MEMBER simpleMap);  # add the semicolon or use a typedef to surpress most errors of the clang code model</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;   Q_PROPERTY(TestObject* childObject MEMBER childObject)</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;public:</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;   Q_INVOKABLE TestObject(QObject *parent = nullptr);</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;   QString stringProperty;</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;   QList&lt;int&gt; simpleList;</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;   QMap&lt;QString, double&gt; simpleMap;</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;   TestObject* childObject;</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;}</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;```</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;**Note:** If you want to use a typedef, read the [Support for using and typedef](#support-for-using-and-typedef) section first!</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;You can serialize (and deserialize) the object with:</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;```cpp</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;auto serializer = new QJsonSerializer(this);</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;try {</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;   //serialize</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;   auto object = new TestObject();</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;   object-&gt;stringProperty = &quot;test&quot;;</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;   object-&gt;simpleList = {1, 2, 3};</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;   object-&gt;simpleMap = {</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;       {&quot;pi&quot;, 3.14},</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;       {&quot;e&quot;, 2.71}</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;   };</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;   object-&gt;childObject = new TestObject(object);</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;   auto json = serializer-&gt;serialize(object);</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;   qDebug() &lt;&lt; json;</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;   delete object;</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;   //deserialize</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;   object = serializer-&gt;deserialize&lt;TestObject&gt;(json);//optional: specify the parent</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;   qDebug() &lt;&lt; object-&gt;stringProperty</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;            &lt;&lt; object-&gt;simpleList</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;            &lt;&lt; object-&gt;simpleMap</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;            &lt;&lt; object-&gt;childObject;</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;   delete object;</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;} catch(QJsonSerializerException &amp;e) {</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;   qDebug() &lt;&lt; e.what();</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;}</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;```</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;For the serialization, the created json would look like this:</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;```json</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;{</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;   &quot;stringProperty&quot;: &quot;test&quot;,</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;   &quot;simpleList&quot;: [1, 2, 3],</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;   &quot;simpleMap&quot;: {</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;       &quot;pi&quot;: 3.14,</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;       &quot;e&quot;: 2.71</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;   },</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;   &quot;childObject&quot;: {</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;       &quot;stringProperty&quot;: &quot;&quot;,</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;       &quot;simpleList&quot;: [],</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;       &quot;simpleMap&quot;: {},</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;       &quot;childObject&quot;: null</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;   }</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;}</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;```</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;## Important Usage Hints {#qtjsonserializer_readme_label_4}</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;In order for the serializer to properly work, there are a few things you have to know and do:</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;1. Only Q_PROPERTY properties of objects/gadgets will be serialized, and of those only properties that are marked to be stored (see [The Property System](https://doc.qt.io/qt-5/properties.html#requirements-for-declaring-properties), STORED attribute)</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;2. For the deserialization of QObjects, they need an invokable constructor, that takes only a parent: `Q_INVOKABLE MyClass(QObject*);`</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;3. The following types are explicitly supported:</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;   - `QObject*` and deriving classes</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;   - Classes/structs marked with `Q_GADGET` (as value or plain pointer only!)</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;   - `QList&lt;T&gt;`, with T beeing any type that is serializable as well</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;   - `QMap&lt;QString, T&gt;`, with T beeing any type that is serializable as well (string as key type is required)</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;   - Simple types, that are supported by QJsonValue (See [QJsonValue::fromVariant](https://doc.qt.io/qt-5/qjsonvalue.html#fromVariant) and [QJsonValue::toVariant](https://doc.qt.io/qt-5/qjsonvalue.html#toVariant))</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;   - `Q_ENUM` and `Q_FLAG` types, as integer or as string</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;       - The string de/serialization of Q_ENUM and Q_FLAG types only works if used as a Q_PROPERTY. Integer will always work.</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;   - `QJson...` types</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;   - `QPair&lt;T1, T2&gt;` and `std::pair&lt;T1, T2&gt;`, of any types that are serializable as well</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;   - `std::tuple&lt;TArgs...&gt;`, of any types that are serializable as well</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;   - Standard QtCore types (QByteArray, QUrl, QVersionNumber, QUuid, QPoint, QSize, QLine, QRect, QLocale, QRegularExpression)</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;       - QByteArray is represented by a base64 encoded string</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;   - Any type you add yourself by extending the serializer (See QJsonTypeConverter documentation)</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;4. While simple types (i.e. `QList&lt;int&gt;`) are supported out of the box, for custom types (like `QList&lt;TestObject*&gt;`) you will have to register converters. This goes for</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;   - QList and QMap: use `QJsonSerializer::registerAllConverters&lt;T&gt;()`</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;   - QList only: use `QJsonSerializer::registerListConverters&lt;T&gt;()`</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;   - QMap only: use `QJsonSerializer::registerMapConverters&lt;T&gt;()`</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;   - QPair and std::pair: use `QJsonSerializer::registerPairConverters&lt;T1, T2&gt;()`</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;   - std::tuple: use `QJsonSerializer::registerTupleConverters&lt;TArgs...&gt;()`</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;   - QSharedPointer/QPointer: use `QJsonSerializer::registerPointerConverters&lt;T&gt;()`</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;5. Polymorphic QObjects are supported. This is done by the serializer via adding a special @@class json property. To make a class polymorphic you can:</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;   - Add `Q_JSON_POLYMORPHIC(true)` (or `Q_CLASSINFO(&quot;polymorphic&quot;, &quot;true&quot;)`) to its definition</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;   - Globally force polyphormism (See QJsonSerializer::polymorphing in the doc)</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;   - Set a dynamic property: `setProperty(&quot;__qt_json_serializer_polymorphic&quot;, true);`</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;6. By default, the `objectName` property of QObjects is not serialized (See [keepObjectName](src/qjsonserializer.h#L20))</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;7. By default, the JSON `null` can only be converted to QObjects. For other types the conversion fails (See [allowDefaultNull](src/qjsonserializer.h#L19))</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;## Support for using and typedef {#qtjsonserializer_readme_label_5}</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;Many converters on the serializer depends on beeing able to get the name of a specific type in order to be able to correctly serialize it. Especially when template types are used, this is required to get the type of the template parameters. This means that some typedefs will not work out of the box, if not correctly registered. This can become rather complicated, because the serializer depends on the somewhat complicated typedef handling of the Qt meta system. There are generally 2 kinds of typedefs described below.</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;### Implicit typedef support {#qtjsonserializer_readme_label_6}</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;Implicit typedefs in this context are understood as typedefs that are registered within Qt using `qRegisterMetaType`. The important part here is that the original type name must be declared via `Q_DECLARE_METATYPE` and typedefs are then registered in Qt after that. A basic example would be a typedef for a custom class:</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;```cpp</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;class MyClass {};</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;Q_DECLARE_METATYPE(MyClass)</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;using MyTypedef = MyClass;</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;qRegisterMetaType&lt;MyClass&gt;();</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;qRegisterMetaType&lt;MyClass&gt;(&quot;MyTypedef&quot;);</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;qDebug() &lt;&lt; QMetaType::typeName(qMetaTypeId&lt;MyTypedef&gt;());</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;//will print &quot;MyClass&quot;, the original type name</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;```</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;Using such typedefs is completely safe, as Qt will internally resolve the correctly, i.e. declaring a property as `Q_PROPERTY(MyTypedef value ...)` will pass the `MyClass` MetaType to the serializer.</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;However, this will not work for the case where a typedef is registered as the &quot;original&quot; type name. For these cases, you need the explicit typedefs.</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;### Explicit typedef support {#qtjsonserializer_readme_label_7}</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;If you for example declare a metatype by a typedef&#39;ed name, this name is considered the &quot;real&quot; name by Qt. The following example shows this for a custom map that is registered as typedef so that it can be used as property on older compilers:</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;```cpp</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;using MyMap = QMap&lt;QString, MyType&gt;;</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;Q_DECLARE_METATYPE(MyMap);</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;qRegisterMetaType&lt;MyMap&gt;();</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;qRegisterMetaType&lt;MyMap&gt;(&quot;QMap&lt;QString, MyType&gt;&quot;);</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;qDebug() &lt;&lt; QMetaType::typeName(qMetaTypeId&lt;QMap&lt;QString, MyType&gt;&gt;());</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;//will print &quot;MyMap&quot;, making it impossible to get the value type</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;```</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;To solve this problem, it is possible to explicity register an &quot;inverse typedef&quot; using QJsonTypeConverter::registerInverseTypedef to tell the serializer what the original name of a given type is. This way the converters can get that typename using QJsonTypeConverter::getCanonicalTypeName instead of the registered one:</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;```cpp</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;QJsonTypeConverter::registerInverseTypedef&lt;MyMap&gt;(&quot;QMap&lt;QString, MyType&gt;&quot;);</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;```</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;</div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;The QJsonTypeConverter::getCanonicalTypeName method will now return &quot;QMap&lt;QString, MyType&gt;&quot; if &quot;MyMap&quot; is passed to it, and thus can correctly extract and use &quot;MyType&quot; as value for the serialization.</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;## Support for alternative Containers {#qtjsonserializer_readme_label_8}</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;Right now, only `QList` and `QMap` ar supported as containers. The reason is, that adding containers requires the registration of converters. Supporting all containers would explode the generated binary, which is why I only support the most common ones.</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;If you need the other containers, you have 2 options:</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;1. Implement a custom `QJsonTypeConverter` (You will still have to register all the converters).</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;2. Create &quot;converter&quot; properties that are used for serialization only. This is the more simple version, but needs to be done for every occurance of that container, and adds some overhead.</div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;</div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;The following example shows how to do that to use `QVector` in code, but serialize as `QList`:</div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;```cpp</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;struct MyGadget {</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;   Q_GADGET</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;   Q_PROPERTY(QList&lt;int&gt; myIntVector READ getMyIntList WRITE setMyIntList) //normal property name, as this one appears in json</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;   //Important: Add &quot;STORED false&quot;:</div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;   Q_PROPERTY(QVector&lt;int&gt; myIntVectorInternal READ getMyIntVector WRITE setMyIntVector STORED false) //will not be serialized</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;</div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;public:</div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;   QVector&lt;int&gt; getMyIntVector() const;</div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;   void setMyIntVector(const QVector&lt;int&gt; &amp;vector) ;</div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;</div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;private:</div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;   QList&lt;int&gt; getMyIntList() const {</div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;       return getMyIntVector().toList();</div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;   }</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;   void setMyIntList(const QList&lt;int&gt; &amp;list) {</div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;       setMyIntVector(QVector&lt;int&gt;::fromList(list));</div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;   }</div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;};</div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;```</div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;</div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;# Documentation {#qtjsonserializer_readme_label_9}</div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;The documentation is available on [github pages](https://skycoder42.github.io/QtJsonSerializer/). It was created using [doxygen](http://www.doxygen.org/). The HTML-documentation and Qt-Help files are shipped</div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;together with the module for both the custom repository and the package on the release page. Please note that doxygen docs do not perfectly integrate with QtCreator/QtAssistant.</div></div><!-- fragment --></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 3 2018 11:03:59 for QtJsonSerializer by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
